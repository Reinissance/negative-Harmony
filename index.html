<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>heavy</title>

  <!-- Generated javascript library includes -->
  <script type="application/javascript" src="./heavy.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.js"></script>
  <script src="https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js"></script>
  <script src="https://unpkg.com/@tonejs/midi"></script>

  <style>
    .horizontal {
      display: flex;
      justify-content: space-evenly;
      align-items: center;
    }

    .widget {
      max-width: 900px;
      margin: auto;
    }

    .row {
      width: 100%;
      margin-bottom: 10px;
    }

    .col {
      display: inline-block;
    }

    .events {
      vertical-align: top;
      margin: 10px;
    }

    .title {
      width: 80%;
      margin: 0 auto;
    }

    .transport {
      padding-left: 10px;
    }

    .parameter-name {
      width: 35%;
      text-align: right;
    }

    .parameter-slider {
      width: 45%;
      padding-left: 10px;
    }

    .parameter-slider input {
      vertical-align: middle;
      width: 100%;
    }

    .parameter-value {
      width: 10%;
      padding-left: 10px;
      text-align: left;
    }

    .link {
      margin: 10px 10px 0 0;
      float: right;
    }

    span {
      text-align: right;
    }
  </style>

  <script type="text/javascript">
    let heavyModule = null;
    let loader = null;
    let midioutPort = null;
    let midiOutputsSelect = null;
    let midiInputs = [];
    let bpm = 120;
    let speed = 1.0;
    let speedSlider = null;
    let player = null;

    let loadedChannelInstruments = {}; // Store necessary instruments for midi file playback
    let availableInstrumentsForProgramChange = {}; // Store available instrument soundfonts provided by webaudiofont per program change number
    let drumInstrument = null; // Create a separate instrument for drum sounds
    let availableDrumSoundsForNote = {};  // Store available drum sounds per note provided by webaudiofont
    let midiNotes = []; // Store the notes played by the midi player to stop them on note off
    let loadedChannelControlValues = {}; // on midiFile load, store the control values for each channel
    let noMidi = true; // Flag to check if no MIDI devices are available
    let lastNotes = []; // Store the last notes played by the midi player to check the piece's key
    let midiData;
    let normal = false;
    let sustain = {};
    let sustainedNodes = {};

    window.onload = function () {
      heavy_Module().then(loadedModule => {
        heavyModule = loadedModule;
        moduleLoaded();
        speedSlider = document.getElementById("speedControl");
        setupMidiPlayer();
      });
      document.getElementById("transportButton").style.visibility = "hidden";
    }

    function moduleLoaded() {
      loader = new heavyModule.AudioLibLoader();
      document.getElementById("transportButton").style.visibility = "visible";
    }

    function start() {
      if (!loader.webAudioContext) {
        loader.init({
          // optional: set audio processing block size, default is 2048
          blockSize: 4,
          // optional: provide a callback handler for [print] messages
          printHook: onPrint,
          // optional: provide a callback handler for [s {sendName} @hv_param] messages
          // sendName "midiOutMessage" is reserved for MIDI output messages!
          sendHook: onSendMessage,
          // optional: pass an existing web audio context, otherwise a new one
          // will be constructed.
          webAudioContext: null
        }).then(() => {
          Tone.start();
          setupGMPlayer();
          var startPrompt = document.getElementById("start_prompt");
          startPrompt.hidden = true;
          var transportButton = document.getElementById("col_transport");
          transportButton.style = "";
          updateSlider_perOktave(1);
          updateSlider_mode(2);

          checkForLinkedMidiFile();

        });
      }
      loader.start();
    }

    function stop() {
      loader.stop();
    }

    function toggleTransport(element) {
      (loader.isPlaying) ? stop() : start();
    }

    function onPrint(message) {
      console.log(message);
    }

    if (navigator.requestMIDIAccess) {
      navigator.requestMIDIAccess()
        .then(onMIDISuccess, onMIDIFailure);
    }

    function onMIDISuccess(midiAccess) {

      noMidi = false;
      var inputs = midiAccess.inputs.values();
      midiInputs = Array.from(midiAccess.inputs.values());
      var midiInputsSelect = document.getElementById("midiInputs");

      // Add MidiPlayer as first MIDI output option
      var option = document.createElement("option");
      option.value = 0;
      option.text = "MidiPlayer";
      midiInputsSelect.add(option);

      midiInputs.forEach((input, index) => {
        var option = document.createElement("option");
        option.value = index;
        option.text = input.name;
        midiInputsSelect.add(option);
      });

      // Preselect the first MIDI input and output
      if (midiInputs.length > 0) {
        midiInputsSelect.selectedIndex = 0;
        // midiInputs[0].onmidimessage = onMIDIMessage;
      }
      midiInputsSelect.onchange = function () {
        var selectedInput = midiInputs[midiInputsSelect.value];
        midiInputs.forEach(input => input.onmidimessage = null); // Clear previous handlers
        if (selectedInput && (midiInputsSelect.selectedIndex > 0)) {
          selectedInput.onmidimessage = onMIDIMessage;
        }
      };


      midiOutputsSelect = document.getElementById("midiOutputs");
      var midiOutputs = [];
      var outputs = midiAccess.outputs.values();
      midiOutputs = Array.from(midiAccess.outputs.values());
      // Add WebAudioFont as first MIDI output option
      var option = document.createElement("option");
      option.value = -1;
      option.text = "WebAudioFont";
      midiOutputsSelect.add(option);

      midiOutputs.forEach((output, index) => {
        var option = document.createElement("option");
        option.value = index;
        option.text = output.name;
        midiOutputsSelect.add(option);
      });

      if (midiOutputs.length > 1) {
        midiOutputsSelect.selectedIndex = 0;
        // midioutPort = midiOutputs[0];
      }

      midiOutputsSelect.onchange = function () {
        if (!midioutPort) {
          // manually send allnotesoff to all channels for webaudiofont
          setTimeout(() => {
            for (const note of midiNotes) {
              handleNoteOff(note.channel, { midi: note.pitch });
            }
          }, 500);
        }
        else {
          // manually send allnotesoff to all channels for external midi devices
          midioutPort.send([0xB0, 120, 0]);
          midioutPort.send([0xB1, 120, 0]);
          midioutPort.send([0xB2, 120, 0]);
          midioutPort.send([0xB3, 120, 0]);
          midioutPort.send([0xB4, 120, 0]);
          midioutPort.send([0xB5, 120, 0]);
          midioutPort.send([0xB6, 120, 0]);
          midioutPort.send([0xB7, 120, 0]);
          midioutPort.send([0xB8, 120, 0]);
          midioutPort.send([0xB9, 120, 0]);
          midioutPort.send([0xBA, 120, 0]);
          midioutPort.send([0xBB, 120, 0]);
        }
        midioutPort = midiOutputs[midiOutputsSelect.value];
        if (midioutPort) {
          midioutPort.onmidimessage = onMidiOutMessage;
          console.log("Selected MIDI output:", midioutPort.name);
        }
        // else {
        // console.error("No MIDI output port available.");
        // }
      };
    }

    function onMIDIFailure(msg) {
      var midiIn = document.getElementById("midiIn");
      midiIn.innerHTML = "No MIDI available.";
      midiOut = document.getElementById("midiOut");
      midiOut.innerHTML = "";
      console.error(`Failed to get MIDI access - ${msg}`);
    }

    function onMIDIMessage(message) {
      if (loader.webAudioWorklet) {
        loader.sendMidi(message.data);
        // console.log("Received MIDI message:", message.data);
      } else {
        loader.audiolib.sendMidi(message.data);
        // console.log("Received MIDI message:", message.data);
      }
    }

    function onMidiOutMessage(message) {
      if (!noMidi && midiOutputsSelect.selectedIndex != 0) {
        try {
          midioutPort.send(message);
          // console.log("Sent MIDI message:", message);
        } catch (error) {
          console.error("Error sending MIDI message:", error);
        }
      }
      else {
        if (noMidi || (midiOutputsSelect != null && midiOutputsSelect.selectedIndex === 0)) {
          channel = message[0] & 0x0F;
          if (message[0] >= 0x80 && message[0] < 0x90) {
            // Note off
            handleNoteOff(channel, {
              midi: message[1]
            });
          } else if (message[0] >= 0x90 && message[0] < 0xA0) {
            // Note on
            if (message[2] === 0) {
              // Note off (velocity 0)
              handleNoteOff(channel, {
                midi: message[1]
              });
            } else {
              // Note on
              handleNoteOnForChannel({
                midi: message[1]
              }, message[2] / 127, channel);
            }
          } else if (message[0] >= 0xB0 && message[0] < 0xC0) {
            // Control change
            if (message[1] === 120) {
              // All notes off
              for (const note of midiNotes) {
                handleNoteOff(note.channel, { midi: note.pitch });
              }
            } else if (message[1] === 7) {
              // Volume
              // console.log("Volume change:", message[2], "on channel:", channel);
              if (channel === 9) {
                drumInstrument.gainNode.gain.value = message[2] / 127;
                // console.log("Volume change:", message[2], "on DRUMchannel");
              } else {
                // console.log("Volume change:", message[2], "on channel:", channel);
                loadedChannelInstruments[channel].gainNode.gain.value = message[2] / 127;
                Tone.Draw.schedule(function(time){
                  var slider = document.getElementById("volumeSlider_" + channel);
                  slider.value = message[2];
                  var v_label = document.getElementById("vol_label_" + channel);
                  v_label.innerHTML = "Volume: " + (message[2] / 127).toFixed(2);
                }, "+0.1");
              }
            } else if (message[1] === 10) {
              // Pan
              if (channel === 9) {
                drumInstrument.panNode.pan.value = (message[2] - 64) / 64;
                // console.log("Pan change:", message[2], "on DRUMchannel");
              } else {
                // console.log("Pan change:", message[2], "on channel:", channel);
                loadedChannelInstruments[channel].panNode.pan.value = (message[2] - 64) / 64;
                Tone.Draw.schedule(function(time){
                  var slider = document.getElementById("panSlider_" + channel);
                  slider.value = (message[2] - 64) / 64;
                  var p_label = document.getElementById("pan_label_" + channel);
                }, "+0.1");
              }
            } else if (message[1] === 64) {
              // Sustain pedal
              if (message[2] > 0) {
                sustain[channel] = true;
              } else {
                for (const node of Object.values(sustainedNodes)) {
                  node.cancel();
                }
                sustain[channel] = false;
                
              }
              // console.log("Sustain pedal:", message[2], "on channel:", channel);
            };
          } else if (message[0] >= 0xC0 && message[0] < 0xD0) {
            // Program change
            // set the instrument for the channel
            if (channel != 9) {
              programNumber = message[1];
              loadedChannelInstruments[channel].preset = availableInstrumentsForProgramChange[programNumber].preset;
            }
          } else if (message[0] >= 0xE0 && message[0] < 0xF0) {
            channel = message[0] & 0x0F;
            // Pitch bend
            console.log("Got Pitch bend:", message[1], "on channel:", channel);
          }
        }
        else {
          console.error("No MIDI output port available.");
        }
      }
    }

    function onSendMessage(sendName, message) {

      switch (sendName) {
        case "midiOutMessage":
          onMidiOutMessage(message);
          break;
        default:
          console.log(sendName, message);
      }
    }

    function sendEvent_allNotesOff() {
      if (loader.webAudioWorklet) {
        loader.sendEvent("allNotesOff");
      } else {
        loader.audiolib.sendEvent("allNotesOff");
      }
    }

    function checkForLinkedMidiFile() {
      const urlParams = new URLSearchParams(window.location.search);
      const midiFileUrl = urlParams.get('midiFile');
      if (midiFileUrl) {
        fetch(midiFileUrl)
          .then(response => response.arrayBuffer())
          .then(data => {
            midiData = new Midi(data);
            parseMidiFile();

            var fileUpload = document.getElementById("midiUpload");
            var fileInput = new File([data], midiFileUrl.split('/').pop(), { type: 'audio/midi' });
            var dataTransfer = new DataTransfer();
            dataTransfer.items.add(fileInput);
            fileUpload.files = dataTransfer.files;
          })
          .catch(error => {
            console.log(error);
            alert('Error loading MIDI file: ' + error);
          });
      } else {
        console.log("No linked MIDI file found.");
        if (midiInputs.length > 0) {
          console.log("loading piano");
          loadInstrumentsForProgramChange(0, 0, "Piano");
        }
      }
    }

    function updateSlider_mode(value) {
      if (loader.webAudioWorklet) {
        loader.sendFloatParameterToWorklet("mode", value);
      } else {
        loader.audiolib.setFloatParameter("mode", value);
      }
      var negRoots = document.getElementById("negRoots");
      negRoots.hidden = (value == 2) ? false : true;
      var perOkt = document.getElementById("perOkt");
      perOkt.hidden = (value == 0) ? true : false;
      normal = perOkt.hidden;
      sendEvent_allNotesOff();
    }

    function updateSlider_negRoot(value) {
      if (loader.webAudioWorklet) {
        loader.sendFloatParameterToWorklet("negRoot", value);
      } else {
        loader.audiolib.setFloatParameter("negRoot", value);
      }
      sendEvent_allNotesOff();
    }

    function updateSlider_perOktave(value) {
      if (loader.webAudioWorklet) {
        loader.sendFloatParameterToWorklet("perOktave", value);
      } else {
        loader.audiolib.setFloatParameter("perOktave", value);
      }
      sendEvent_allNotesOff();
    }

    function parseMidiFile() {
      console.log(midiData);

      // reset speed and speed slider to 1
      speedSlider.value = 1.0;
      speed = 1.0;

      const label = document.querySelector('label[for="speedControl"]');
      //Get bpm from midi file if present
      if (midiData.header.tempos.length > 0) {
        bpm = midiData.header.tempos[0]["bpm"];
        // console.log("BPM from MIDI file:", bpm);
        Tone.Transport.bpm.value = (bpm).toFixed(2);
        if (label) {
          label.textContent = "Playback Speed: " + (bpm * speed).toFixed(2) + "bpm";
        }
      }
      else {
        // console.log("No BPM found in MIDI file. Defaulting to 120 bpm.");
        Tone.Transport.bpm.value = 120; // Default to 120 bpm
        speedSlider.label = "Speed: 120bpm";
        if (label) {
          label.textContent = "Playback Speed: " + (bpm * speed).toFixed(2) + "bpm";
        }
      }
      if (midiData.header.name) {
        document.getElementById("midiFileName").innerHTML = midiData.header.name;
      }

      // Schedule the events
      scheduleMIDIEvents(midiData);
    }

    function setupMidiPlayer() {
      // MIDI player code

      var playing = false;
      var playBtn = document.getElementById('playMidi');
      let parts = []; // Store the scheduled MIDI parts

      // Handle MIDI file upload
      document.getElementById('midiUpload').addEventListener('change', (event) => {

        // make playbutton unrespondable
        playBtn.innerText = "Loading MIDI file...";
        playBtn.style.color = "gray";
        playBtn.disabled = true;

        cleanup();

        // console.log("Loading MIDI file...");
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = async function (e) {
            const midi = new Midi(e.target.result);
            midiData = midi; // Store parsed MIDI data
            parseMidiFile();
            playBtn.disabled = false;
            playBtn.innerText = "Play MIDI";
            playBtn.style.color = "red";
          };
          reader.readAsArrayBuffer(file);
          // console.log("MIDI file loaded.");
        }
        else {
          console.error("No MIDI file selected.");
        }
      });

      // Function to parse the MIDI file and schedule events
      window.scheduleMIDIEvents = function (midi) {
        // Clear any previous scheduled parts
        parts.forEach(part => part.dispose());
        parts = [];

        // Create a part for each channel
        const channelParts = {};

        // Schedule tempos from header
        if (Array.isArray(midi.header.tempos)) {
          midi.header.tempos.forEach(tempo => {
            if (!channelParts[0]) {
              channelParts[0] = new Tone.Part();
            }
            channelParts[0].add(tempo.time, {
              type: 'tempo',
              bpm: tempo.bpm
            });
          });
        }

        // Set timeSignature
        if (midi.header.timeSignatures.length > 0) {
          const timeSignature = midi.header.timeSignatures[0];
          console.log("Time Signature:", timeSignature.timeSignature);
          Tone.Transport.timeSignature = timeSignature.timeSignature;
        }

        // Loop through each track in the MIDI file
        midi.tracks.forEach((track, trackIndex) => {
          const channel = track.channel;
          if (!channelParts[channel]) {
            channelParts[channel] = new Tone.Part();
          }

          // Schedule note events
          track.notes.forEach(note => {
            channelParts[channel].add(note.time, {
              type: 'note',
              midi: note.midi,
              duration: note.duration,
              velocity: (channel === 9) ? Math.floor(note.velocity * 127) : Math.floor(Math.pow(note.velocity, 2) * 127),
              channel: channel,
              length: note.time + note.duration
            });
          });

          // Schedule control change events
          Object.values(track.controlChanges).forEach(controlChange => {
            controlChange.forEach(cc => {
              // add the first to loadedChannelControlValues in order to have a starting value for the controls
              if (!loadedChannelControlValues[channel]) {
                loadedChannelControlValues[channel] = {};
              }
              if (!loadedChannelControlValues[channel][cc.number]) {
                loadedChannelControlValues[channel][cc.number] = cc.value;
              }
              channelParts[channel].add(cc.time, {
                type: 'controlChange',
                number: cc.number,
                value: cc.value,
                channel: channel
              });
            });
          });

          // Schedule program change events
          if (track.instrument !== undefined) {
            const programChange = Math.max(track.instrument["number"] || 0, 0);
            if (channel != 9 && channel >= 0) {
              // preload the instruments for the program change and setup mixer channels
              loadInstrumentsForProgramChange(channel, programChange, track.name);
            }
            if (programChange >= 0) {
              channelParts[channel].add(0, {
                type: 'programChange',
                number: programChange,
                channel: channel
              });
            }
            if (channel === 9) {
              track.notes.forEach(note => {
                if (!availableDrumSoundsForNote[note.midi]) {
                  // preload the drum sounds for each used note
                  loadDrumSoundForNote(note.midi);
                }
              });
            }
          }

          // Schedule pitch bend events
          if (track.pitchBends.length > 0) {
            track.pitchBends.forEach(bend => {
              channelParts[channel].add(bend.time, {
                type: 'pitchBend',
                value: (bend.value + 1) * 8192,
                channel: channel
              });
            });
          }

          // Store the last notes played by the midi player to check the piece's key
          if (track.notes.length > 0 && channel != 9) {
            const lastNote = track.notes[track.notes.length - 1].midi;
            if (!lastNotes.includes(lastNote)) {
              lastNotes.push(lastNote);
            }
          }
          //end of looping track
        });

        // Check the piece's key
        if (lastNotes.length > 0) {
          // get the lowest note
          const lowestNote = Math.min(...lastNotes);
          // set root input to the lowest note
          const negRootRadios = document.getElementsByName("negRoot");
          for (const radio of negRootRadios) {
            if ((parseFloat(radio.value) + 3) % 12 === (lowestNote + 6) % 12) {
              radio.checked = true;
              updateSlider_negRoot(parseFloat(radio.value));
              break;
            } else {
              radio.checked = false;
            }
          }
        }

        // Start all parts
        Object.values(channelParts).forEach(part => {
          part.callback = (time, event) => {
            switch (event.type) {
              case 'note':
                onMIDIMessage({
                  data: [0x90 + event.channel, event.midi, event.velocity]
                });
                const noteOffTime = event.length / speed;
                Tone.Transport.schedule((releaseTime) => {
                  onMIDIMessage({
                    data: [0x80 + event.channel, event.midi, 0]
                  });
                  // console.log("Note off:", event.midi, "at time:", releaseTime);
                }, noteOffTime);
                break;
              case 'controlChange':
                onMIDIMessage({
                  data: [0xB0 + event.channel, event.number, Math.floor(event.value * 127)]
                });
                break;
              case 'programChange':
                onMIDIMessage({
                  data: [0xC0 + event.channel, event.number]
                });
                break;
              case 'pitchBend':
                if (!normal) {
                  event.value = (event.value - 8192) * -1 + 8192;
                }
                onMIDIMessage({
                  data: [0xE0 + event.channel, event.value & 0x7F, event.value >> 7]
                });
                break;
              case 'tempo':
                // Tone.Transport.bpm.rampTo(event.bpm * speed, 0.1);
                Tone.Draw.schedule(function(time){
                  const label = document.querySelector('label[for="speedControl"]');
                  if (label) {
                    label.textContent = "Playback Speed: " + (event.bpm * speed).toFixed(2) + "bpm";
                  }
                }, "+0.1");
                break;
            }
          };
          part.start();
          parts.push(part);
        });
      }

      // Play the MIDI file
      document.getElementById('playMidi').addEventListener('click', () => {
        if (!playing) {
          if (midiData) {
            playBtn.innerText = "Stop Playback";
            playing = true;
            Tone.Transport.start();
            Tone.Transport.scheduleOnce(() => {
              playBtn.innerText = "Play MIDI";
              playing = false;
              Tone.Transport.stop();
              Tone.Transport.position = 0; // Reset to the beginning of the file
              sendEvent_allNotesOff();
            }, midiData.duration);
          } else {
            alert("Please load a MIDI file first.");
            console.error("No MIDI file loaded or parsed.");
          }
        } else {
          console.log("Stopping playback...");
          Tone.Transport.stop();
          Tone.Transport.position = 0;
          playBtn.innerText = "Play MIDI";
          playing = false;
          sendEvent_allNotesOff();
        }
      });

      // Control playback speed with a range input
      document.getElementById('speedControl').addEventListener('input', function (event) {
        speed = parseFloat(event.target.value);
        Tone.Transport.bpm.value = (bpm * speed).toFixed(2);
        const label = document.querySelector('label[for="speedControl"]');
        if (label) {
          label.textContent = "Playback Speed: " + (bpm * speed).toFixed(2) + "bpm";
        }
      });
    }

    function setupGMPlayer() {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const player = new WebAudioFontPlayer();

      // Function to load the preset
      window.loadPreset = function (url) {
        return new Promise((resolve, reject) => {
          var name = '_tone_' + url.split('/').pop().replace('.js', '');
          player.loader.startLoad(audioContext, url, name);
          // player.loader.waitLoad(function () {
          // console.log('Preset loaded:', name);
          resolve(name);
          // });
        });
      }

      window.loadDrumSound = function (url) {
        return new Promise((resolve, reject) => {
          var name = '_drum_' + url;
          var domained_url = "https://surikov.github.io/webaudiofontdata/sound/128" + url + ".js"
          player.loader.startLoad(audioContext, domained_url, name);
          // player.loader.waitLoad(function () {
          // console.log('Drum sound loaded:', name);
          resolve(name);
          // });
        });
      }

      // Play note on event after preset is fully loaded
      window.handleNoteOnForChannel = function (note, velocity, channel) {
        // console.log("Velocity:", velocity, "Channel:", channel, "Note:", note.midi);
        handleNoteOff(channel, note.midi);
        if (channel === 9) {
          if (window[drumInstrument.notes[note.midi]] === undefined) {
            // console.log('Drum sound is missing or still loading:', note.midi, drumInstrument);
            return;
          }
          var envelope = player.queueWaveTable(audioContext, drumInstrument.gainNode, window[drumInstrument.notes[note.midi]],
            audioContext.currentTime, note.midi, 9999, velocity); // Long duration to ensure sustained note
        }
        else {
          var instrument = loadedChannelInstruments[channel];
          if (instrument.preset === "loading") {
            // console.log('Instrument is still loading:', channel, instrument);
            return;
          }
          var envelope = player.queueWaveTable(audioContext, instrument.gainNode, window[instrument.preset],
            audioContext.currentTime, note.midi, 9999, velocity); // Long duration to ensure sustained note
        }

        // Store the audio source for later stopping it on note off
        var note = {
          channel: channel,
          pitch: note.midi,
          envelope: envelope
        };
        midiNotes.push(note);
      }

      window.handleNoteOff = function (channel, note) {
        let noteRemoved = false;
        midiNotes = midiNotes.filter((midiNote) => {
          if (!noteRemoved && midiNote.pitch === note.midi && midiNote.channel === channel) {
            if (midiNote.envelope) {
              if (!sustain[channel]) {
                midiNote.envelope.cancel();
              } else {
                sustainedNodes[note.midi] = midiNote.envelope;
              }
            }
            noteRemoved = true;
            return false;
          }
          return true;
        });
      }

      window.loadInstrumentsForProgramChange = function (channel, programNumber, name) {
        //preload the instruments for the program change and setup mixer channels
        if (!availableInstrumentsForProgramChange[programNumber]) {
          links = linksForProgramChange(programNumber);
          // console.log('Available instruments for program change:', availableInstrumentsForProgramChange[programNumber]);
          const instrumentUrl = "https://surikov.github.io/webaudiofontdata/sound/" + links.urls[0] + ".js"; // Load the first instrument for now
          var channelInstrument = createChannelInstrumentForChannel(channel, "loading");
          loadPreset(instrumentUrl)
            .then((preset) => {
              availableInstrumentsForProgramChange[programNumber].preset = preset; // Ensure preset is set correctly
              availableInstrumentsForProgramChange[programNumber].usingChannels.push(channel);
              channelInstrument.preset = preset; // Store the loaded preset
              loadedChannelInstruments[channel] = channelInstrument;
              loadedChannelInstruments[channel].programIndex = 0;
              //create controls for the channel
              createControlsForChannel(channel, programNumber, name);
              // console.log('Preset loaded and decoded. AVAILABLE:', availableInstrumentsForProgramChange, "channelInsts:", loadedChannelInstruments);
            })
            .catch((error) => {
              console.error('Error loading preset:', error);
            });
        } else {
          if (availableInstrumentsForProgramChange[programNumber].preset === "loading") {
            // console.log('Instrument is already loading:', programNumber, availableInstrumentsForProgramChange[programNumber]);
            setTimeout(() => {
              loadInstrumentsForProgramChange(channel, programNumber, name);
            }, 300);
            return;
          }
          else {
            availableInstrumentsForProgramChange[programNumber].usingChannels.push(channel);
            loadedChannelInstruments[channel] = createChannelInstrumentForChannel(channel, availableInstrumentsForProgramChange[programNumber].preset);
            createControlsForChannel(channel, programNumber, name);
          }
        }
      }

      window.loadDrumSoundForNote = function (note) {
        if (!availableDrumSoundsForNote[note]) {
          links = linksForDrumSound(note);
          // console.log('Available drum sounds for note:', availableDrumSoundsForNote[note]);
          const drumSoundUrl = links.urls[0]; // Load the first drum sound for now
          addNoteToDrumInstrument(note, "loading");
          if (drumSoundUrl != undefined) {
          loadDrumSound(drumSoundUrl)
            .then((preset) => {
              availableDrumSoundsForNote[note].preset = preset;
              addNoteToDrumInstrument(note, preset);
              // console.log('Drum sound loaded and decoded. AVAILABLE:', availableDrumSoundsForNote);
              createDrumInstrumentControl(note, 0);
            })
            .catch((error) => {
              console.error('Error loading drum sound:', error);
            });
          } else {
            console.warn("No drum sound URL found for note:", note);
          } 
        } else {
          if (availableDrumSoundsForNote[note].preset === "loading") {
            // console.log('Drum sound is already loading:', note, availableDrumSoundsForNote[note]);
            setTimeout(() => {
              loadDrumSoundForNote(note);
            }, 300);
            return;
          }
          else {
            addNoteToDrumInstrument(note, availableDrumSoundsForNote[note].preset);
            createDrumInstrumentControl(note, 0);
          }
        }
      }

      function addNoteToDrumInstrument(note, preset) {
        if (!drumInstrument) {
          var gainNode = audioContext.createGain();
          gainNode.gain.value = 1;
          var panNode = audioContext.createStereoPanner();
          panNode.pan.value = 0;
          gainNode.connect(panNode);
          panNode.connect(audioContext.destination);
          drumInstrument = { notes: {}, gainNode: gainNode, panNode: panNode };
        }
        drumInstrument.notes[note] = preset;
        // console.log('Drum instrument:', drumInstrument);
      }

      function createChannelInstrumentForChannel(channel, preset) {
        var gainNode = audioContext.createGain();
        gainNode.gain.value = 1;
        var panNode = audioContext.createStereoPanner();
        panNode.pan.value = 0;
        gainNode.connect(panNode);
        panNode.connect(audioContext.destination);
        var channelInstrument = { preset: preset, programIndex: 0, panNode: panNode, gainNode: gainNode };
        return channelInstrument;
      }

      function linksForProgramChange(i) {
        filter = ""
        if (i < 10) {
          filter = "00" + i;
        }
        else if (i < 100) {
          filter = "0" + i;
        } else {
          filter = i.toString();
        }
        var nn = player.loader.findInstrument(i);
        availableInstrumentsForProgramChange[i] = { name: player.loader.instrumentInfo(nn).title, urls: player.loader.instrumentKeys().filter(url => url.startsWith(filter)), preset: "loading", usingChannels: [] };
        return availableInstrumentsForProgramChange[i];
      }

      function linksForDrumSound(i) {
        filter = i.toString();
        var nn = player.loader.findDrum(i);
        info = player.loader.drumInfo(nn);
        availableDrumSoundsForNote[i] = { name: info.title, urls: player.loader.drumKeys().filter(url => url.startsWith(filter)), preset: "loading" };
        // console.log("Drum sound:", i, availableDrumSoundsForNote[i]);
        return availableDrumSoundsForNote[i];
      }
    }

    function cleanup() {
      lastNotes = [];
      var midiFileName = document.getElementById("midiFileName");
      midiFileName.innerHTML = "";
      var element = document.getElementById("file_controls");
      for (var i = element.childNodes.length - 1; i >= 0; i--) {
        element.childNodes[i].remove();
      }
      loadedChannelControlValues = {};
      for (program in availableInstrumentsForProgramChange) {
        // release the preset for the program change
        window[availableInstrumentsForProgramChange[program].preset] = null;
        delete availableInstrumentsForProgramChange[program];
      }
      for (note in availableDrumSoundsForNote) {
        // release the drum sound for the note
        window[availableDrumSoundsForNote[note].preset] = null;
        delete availableDrumSoundsForNote[note];
      }
    }

    function createControlsForChannel(channel, programNumber, name) {
      // Remove old controls if present
      let element = document.getElementById("channel_controls_" + channel);
      let nextSibling = element ? element.nextElementSibling : null;
      if (element) element.remove();

      let controls = document.getElementById("file_controls");
      let controlDiv = document.createElement("div");
      controlDiv.id = "channel_controls_" + channel;
      controlDiv.style = "display: flex; flex-direction: column; margin: 10px;";

      let nameHeader = document.createElement("h3");
      nameHeader.innerHTML = name;
      controlDiv.appendChild(nameHeader);

      let label = document.createElement("label");
      label.innerHTML = `<em>Channel ${channel} - Program ${programNumber}:</em> <br>${availableInstrumentsForProgramChange[programNumber].name}`;
      controlDiv.appendChild(label);

      // Create a select element for program change
      let select = document.createElement("select");
      select.id = "programChange_" + channel;
      availableInstrumentsForProgramChange[programNumber].urls.forEach((url, i) => {
      let option = document.createElement("option");
      option.value = i;
      option.text = url;
      select.appendChild(option);
      });
      select.selectedIndex = loadedChannelInstruments[channel].programIndex;
      select.onchange = function () {
      availableInstrumentsForProgramChange[programNumber].usingChannels.pop(channel);
      availableInstrumentsForProgramChange[programNumber].preset = "loading";
      loadedChannelInstruments[channel].preset = "loading";
      let instrumentUrl = availableInstrumentsForProgramChange[programNumber].urls[select.selectedIndex];
      loadPreset("https://surikov.github.io/webaudiofontdata/sound/" + instrumentUrl + ".js")
        .then((preset) => {
        availableInstrumentsForProgramChange[programNumber].preset = preset;
        loadedChannelInstruments[channel].preset = preset;
        loadedChannelInstruments[channel].programIndex = select.selectedIndex;
        createControlsForChannel(channel, programNumber, name);
        document.getElementById("programChange_" + channel).selectedIndex = loadedChannelInstruments[channel].programIndex;
        })
        .catch((error) => console.error('Error loading preset:', error));
      };
      controlDiv.appendChild(select);

      // Volume control
      let vol_label = document.createElement("label");
      vol_label.id = "vol_label_" + channel;
      vol_label.style = "margin-top: 10px;";
      let volumeSlider = document.createElement("input");
      volumeSlider.id = "volumeSlider_" + channel;
      volumeSlider.type = "range";
      volumeSlider.min = 0;
      volumeSlider.max = 127;
      volumeSlider.value = (channel in loadedChannelControlValues && 7 in loadedChannelControlValues[channel])
      ? loadedChannelControlValues[channel][7] * 127
      : loadedChannelInstruments[channel].gainNode.gain.value * 127;
      vol_label.innerHTML = `Volume: ${(volumeSlider.value / 127).toFixed(2)}`;
      volumeSlider.setAttribute('data-channel', channel);
      volumeSlider.oninput = function (event) {
      let slider = event.target;
      let channel = slider.getAttribute('data-channel');
      loadedChannelInstruments[channel].gainNode.gain.value = slider.value / 127;
      document.getElementById("vol_label_" + channel).innerHTML = `Volume: ${(slider.value / 127).toFixed(2)}`;
      };
      controlDiv.appendChild(vol_label);
      controlDiv.appendChild(volumeSlider);

      // Pan control
      let pan_label = document.createElement("label");
      pan_label.id = "pan_label_" + channel;
      let panSlider = document.createElement("input");
      panSlider.id = "panSlider_" + channel;
      panSlider.type = "range";
      panSlider.min = -1;
      panSlider.max = 1;
      panSlider.step = 0.01;
      panSlider.value = (channel in loadedChannelControlValues && 10 in loadedChannelControlValues[channel])
      ? loadedChannelControlValues[channel][10] * 2 - 1
      : loadedChannelInstruments[channel].panNode.pan.value;
      pan_label.innerHTML = `Panning: ${parseFloat(panSlider.value).toFixed(2)}`;
      panSlider.setAttribute('data-channel', channel);
      panSlider.oninput = function (event) {
      let slider = event.target;
      let channel = slider.getAttribute('data-channel');
      loadedChannelInstruments[channel].panNode.pan.value = slider.value;
      document.getElementById("pan_label_" + channel).innerHTML = `Panning: ${parseFloat(slider.value).toFixed(2)}`;
      };
      controlDiv.appendChild(pan_label);
      controlDiv.appendChild(panSlider);

      if (nextSibling) {
      controls.insertBefore(controlDiv, nextSibling);
      } else {
      controls.appendChild(controlDiv);
      }
    }

    function createDrumInstrumentControl(note, sf2Index) {
      let availableSoundsForNote = availableDrumSoundsForNote[note];
      let controlDiv = document.getElementById("drum_controls");
      let noteDivs = document.getElementById("drumNoteDivs");
      if (!controlDiv) {
      let controls = document.getElementById("file_controls");
      controlDiv = document.createElement("div");
      controlDiv.id = "drum_controls";
      controlDiv.style = "display: flex; flex-direction: column; margin: 10px; width: 100%;";

      let nameHeader = document.createElement("h3");
      nameHeader.innerHTML = "Drum Instrument";
      nameHeader.className = "title";
      controlDiv.appendChild(nameHeader);

      let vol_label = document.createElement("label");
      vol_label.id = "vol_label_drum";
      vol_label.style = "margin-top: 10px;";
      let volumeSlider = document.createElement("input");
      volumeSlider.id = "volumeSlider_drum";
      volumeSlider.type = "range";
      volumeSlider.min = 0;
      volumeSlider.max = 127;
      volumeSlider.value = (9 in loadedChannelControlValues && 7 in loadedChannelControlValues[9])
        ? loadedChannelControlValues[9][7] * 127
        : drumInstrument.gainNode.gain.value * 127;
      vol_label.innerHTML = `Volume: ${(volumeSlider.value / 127).toFixed(2)}`;
      volumeSlider.oninput = function (event) {
        drumInstrument.gainNode.gain.value = event.target.value / 127;
        document.getElementById("vol_label_drum").innerHTML = `Volume: ${(event.target.value / 127).toFixed(2)}`;
      };
      controlDiv.appendChild(vol_label);
      controlDiv.appendChild(volumeSlider);

      let pan_label = document.createElement("label");
      pan_label.id = "pan_label_drum";
      let panSlider = document.createElement("input");
      panSlider.id = "panSlider_drum";
      panSlider.type = "range";
      panSlider.min = -1;
      panSlider.max = 1;
      panSlider.step = 0.01;
      panSlider.value = (9 in loadedChannelControlValues && 10 in loadedChannelControlValues[9])
        ? loadedChannelControlValues[9][10] * 2 - 1
        : drumInstrument.panNode.pan.value;
      pan_label.innerHTML = `Panning: ${parseFloat(panSlider.value).toFixed(2)}`;
      panSlider.oninput = function (event) {
        drumInstrument.panNode.pan.value = event.target.value;
        document.getElementById("pan_label_drum").innerHTML = `Panning: ${parseFloat(event.target.value).toFixed(2)}`;
      };
      controlDiv.appendChild(pan_label);
      controlDiv.appendChild(panSlider);

      let noteHeader = document.createElement("h4");
      noteHeader.innerHTML = "Drum Notes:";
      noteHeader.className = "title";
      controlDiv.appendChild(noteHeader);

      noteDivs = document.createElement("div");
      noteDivs.id = "drumNoteDivs";
      noteDivs.style = "display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between;";
      controlDiv.appendChild(noteDivs);

      controls.appendChild(controlDiv);
      }

      let noteDiv = document.getElementById("drumNoteDiv" + availableSoundsForNote.name);
      let nextSibling = noteDiv ? noteDiv.nextElementSibling : null;
      if (noteDiv) noteDiv.remove();

      noteDiv = document.createElement("div");
      noteDiv.id = "drumNoteDiv" + availableSoundsForNote.name;

      let noteLabel = document.createElement("label");
      noteLabel.innerHTML = `${availableSoundsForNote.name}: `;
      noteDiv.appendChild(noteLabel);

      let noteSelect = document.createElement("select");
      noteSelect.id = "drumNoteSelect" + availableSoundsForNote.name;
      noteSelect.style = "margin-top: 10px;";
      availableSoundsForNote.urls.forEach((url, i) => {
      let option = document.createElement("option");
      option.value = i;
      option.text = url;
      noteSelect.appendChild(option);
      });
      noteSelect.selectedIndex = sf2Index;
      noteSelect.onchange = function (event) {
      availableDrumSoundsForNote[note].preset = "loading";
      drumInstrument.notes[note] = "loading";
      let index = event.target.selectedIndex;
      let drumSoundUrl = availableSoundsForNote.urls[index];
      loadDrumSound(drumSoundUrl)
        .then((preset) => {
        availableDrumSoundsForNote[note].preset = preset;
        drumInstrument.notes[note] = preset;
        createDrumInstrumentControl(note, index);
        event.target.selectedIndex = index;
        })
        .catch((error) => console.error('Error loading drum sound:', error));
      };
      noteDiv.appendChild(noteSelect);

      if (nextSibling) {
      noteDivs.insertBefore(noteDiv, nextSibling);
      } else {
      noteDivs.appendChild(noteDiv);
      }
    }
  </script>
</head>

<body>
  <div class="widget">
    <div class="title horizontal">
      <div class="col">
        <h2>negative Harmony</h2>
        <p><em>Playback MIDI-Files possibly in negative Harmony.</em></p>
      </div>
      <div id="col_transport" class="col transport"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgb(255, 255, 255) 0%, rgba(0, 0, 0, 0.687) 100%); z-index: 9999; display: flex; justify-content: center; align-items: center;">
        <div style="text-align: center;">
          <h3 id="start_prompt" style="color: red;">please click start here first:</h3>
          <label>
            start / stop
            <input type="checkbox" id="transportButton" onchange="toggleTransport();">
          </label>
        </div>
      </div>
    </div>
    <div class="horizontal" style="text-align: center;">
      <div style="display: flex; flex-direction: column; margin: 10px;">
        <h3>Midi-Player</h3>
        <input type="file" id="midiUpload" accept=".mid" style="margin-bottom: 10px;" />
        <button id="playMidi" style="margin-bottom: 10px; color: red; font-weight: bold;">Play MIDI</button>
        <label for="speedControl">Playback Speed: </label>
        <input type="range" id="speedControl" min="0.5" max="2" value="1" step="0.01" />
      </div>
      <div>
        <div id="midiIn">
          <div>MIDI input:</div>
          <select id="midiInputs" onchange="console.log(this.value)"></select>
        </div>
        <div id="midiOut" style="margin-top: 20px;">
          <div>MIDI output:</div>
          <select id="midiOutputs" onchange="console.log(this.value)"></select>
        </div>
      </div>
      <div style="text-align: center;">
        <div class="col events">
          MIDI Panic:<br>
          <button type="button" id="trigger_allNotesOff" onclick="sendEvent_allNotesOff();">allNotesOff</button><br>
        </div>
      </div>
    </div>
    <div style="display: flex; justify-content: space-around; align-items: center;">
      <div>
        <h2>Mode:</h2>
        <div>
          <input id="parameter_mode_1" type="radio" name="mode" value="0.0" onchange="updateSlider_mode(value);">
          <label for="parameter_mode_1">normal</label><br>
          <input id="parameter_mode_2" type="radio" name="mode" value="1.0" onchange="updateSlider_mode(value);">
          <label for="parameter_mode_2"
            title="Mirrors notes around the axis of the middle D (C Major becomes A minor and vice versa).">lefthand
            Piano</label><br>
          <input id="parameter_mode_3"
            title="Mirrors notes around an axis between the 3rds of the root note (eg. C Major becomes C minor and vice versa)."
            type="radio" name="mode" value="2.0" checked onchange="updateSlider_mode(value);">
          <label for="parameter_mode_3">negative Harmony</label><br>
        </div>
      </div>
      <div id="negRoots">
        <h3>Root:</h3>
        <div>
          <input id="parameter_negRoot_1" type="radio" name="negRoot" value="57"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_1">Gb</label><br>
          <input id="parameter_negRoot_2" type="radio" name="negRoot" value="64"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_2">Db</label><br>
          <input id="parameter_negRoot_3" type="radio" name="negRoot" value="59"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_3">Ab</label><br>
          <input id="parameter_negRoot_4" type="radio" name="negRoot" value="66"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_4">Eb</label><br>
          <input id="parameter_negRoot_5" type="radio" name="negRoot" value="61"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_5">Bb</label><br>
          <input id="parameter_negRoot_6" type="radio" name="negRoot" value="56"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_6">F</label><br>
          <input id="parameter_negRoot_7" type="radio" name="negRoot" value="63" checked
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_7">C</label><br>
          <input id="parameter_negRoot_8" type="radio" name="negRoot" value="58"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_8">G</label><br>
          <input id="parameter_negRoot_9" type="radio" name="negRoot" value="65"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_9">D</label><br>
          <input id="parameter_negRoot_10" type="radio" name="negRoot" value="60"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_10">A</label><br>
          <input id="parameter_negRoot_11" type="radio" name="negRoot" value="67"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_11">E</label><br>
          <input id="parameter_negRoot_12" type="radio" name="negRoot" value="62"
            onchange="updateSlider_negRoot(value);">
          <label for="parameter_negRoot_12">B(deutsch: H)</label><br>
        </div>
      </div>
      <div id="perOkt">
        <h3>perOktave</h3>
        <div class="col parameter-slider">
          <input id="parameter_perOktave" type="checkbox" checked
            onchange="updateSlider_perOktave(this.checked ? 1.0 : 0.0);">
        </div>
      </div>
    </div>
    <br>
    <h1 id="midiFileName" class="title" style="width: 100%;"></h1>
    <div id="file_controls"
      style="display: flex; flex-direction: row; justify-content: space-between; margin: 10px; flex-wrap: wrap;"></div>
    <div class="row">
      <span class="link"><em>powered by <a
            href="https://github.com/Wasted-Audio/hvcc"><strong>heavy</strong></em></a></span>
    </div>
  </div>
</body>

</html>